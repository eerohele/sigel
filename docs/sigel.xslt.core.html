<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>sigel.xslt.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Sigel</span> <span class="project-version">0.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction</span></div></a></li><li class="depth-1 "><a href="sources.html"><div class="inner"><span>XML Sources</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sigel</span></div></div></li><li class="depth-2 branch"><a href="sigel.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="sigel.extension.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>extension</span></div></a></li><li class="depth-2 branch"><a href="sigel.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-2 branch"><a href="sigel.saxon.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>saxon</span></div></a></li><li class="depth-2 branch"><a href="sigel.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>xpath</span></div></div></li><li class="depth-3"><a href="sigel.xpath.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>xslt</span></div></div></li><li class="depth-3 branch"><a href="sigel.xslt.components.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>components</span></div></a></li><li class="depth-3 branch current"><a href="sigel.xslt.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3"><a href="sigel.xslt.elements.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>elements</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="sigel.xslt.core.html#var-*compiler*"><div class="inner"><span>*compiler*</span></div></a></li><li class="depth-1"><a href="sigel.xslt.core.html#var-apply-templates"><div class="inner"><span>apply-templates</span></div></a></li><li class="depth-1"><a href="sigel.xslt.core.html#var-compile-edn"><div class="inner"><span>compile-edn</span></div></a></li><li class="depth-1"><a href="sigel.xslt.core.html#var-compile-sexp"><div class="inner"><span>compile-sexp</span></div></a></li><li class="depth-1"><a href="sigel.xslt.core.html#var-compile-source"><div class="inner"><span>compile-source</span></div></a></li><li class="depth-1"><a href="sigel.xslt.core.html#var-compile-xslt"><div class="inner"><span>compile-xslt</span></div></a></li><li class="depth-1"><a href="sigel.xslt.core.html#var-compiler"><div class="inner"><span>compiler</span></div></a></li><li class="depth-1"><a href="sigel.xslt.core.html#var-pipeline"><div class="inner"><span>pipeline</span></div></a></li><li class="depth-1"><a href="sigel.xslt.core.html#var-transform"><div class="inner"><span>transform</span></div></a></li><li class="depth-1"><a href="sigel.xslt.core.html#var-transform-to-file"><div class="inner"><span>transform-to-file</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">sigel.xslt.core</h1><div class="doc"><div class="markdown"><p>Write and execute XSLT transformations with Clojure.</p>
<h2><a href="#xml-namespaces" name="xml-namespaces"></a>XML namespaces</h2>
<p>Scenario:</p>
<ul>
  <li>Your source XML document is in an XML namespace.</li>
  <li>You want to transform that document with Sigel into the same namespace.</li>
  <li>You want to write literal XML elements in your transformation, instead of  using <code>xsl:element</code>.</li>
</ul>
<p>For example, you want to transform this:</p>
<pre><code class="xml">&lt;a xmlns="my-ns"/&gt;
</code></pre>
<p>To this:</p>
<pre><code class="xml">&lt;b xmlns="my-ns"/&gt;
</code></pre>
<p>In your XSLT transformation, you want to write something like this:</p>
<pre><code>(xsl/template {:match "a"} [:b])
</code></pre>
<p>Instead of this:</p>
<pre><code>(xsl/template {:match "a"}
  (xsl/element {:name "b"}))
</code></pre>
<p>If you create a literal element with <code>[:b]</code>, though, clojure.data.xml puts it into the empty namespace. That means that the XSLT stylesheet Sigel produces will have this:</p>
<pre><code class="xml">&lt;xsl:template match="a"&gt;
  &lt;!-- note the empty xmlns namespace declaration --&gt;
  &lt;b xmlns=""/&gt;
&lt;/xsl:template&gt;
</code></pre>
<p>When what you actually want is this:</p>
<pre><code class="xml">&lt;xsl:template match="a"&gt;
  &lt;b/&gt;
&lt;/xsl:template&gt;
</code></pre>
<p>To do that, you must first set up your namespace with <code>clojure.data.xml/alias-uri</code>:</p>
<pre><code class="clojure">(xml/alias-uri 'my-ns "my-ns-uri")
</code></pre>
<p>You then need to set the <code>xmlns</code> attribute of your stylesheet and use the <code>my-ns</code> prefix when emitting literal XML elements:</p>
<pre><code class="clojure">(xsl/stylesheet {:version 3.0 :xmlns "my-ns-uri"}
  (xsl/template {:match "a"} [::my-ns/b]))
</code></pre></div></div><div class="public anchor" id="var-*compiler*"><h3>*compiler*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><div class="markdown"><p>A default XSLT compiler.</p>
<p>If you don’t pass in your own <a href="http://www.saxonica.com/html/documentation/javadoc/net/sf/saxon/s9api/XsltCompiler.html">XsltCompiler</a> instance when compiling a stylesheet, Sigel uses this instance.</p></div></div></div><div class="public anchor" id="var-apply-templates"><h3>apply-templates</h3><div class="usage"><code>(apply-templates transformer source)</code><code>(apply-templates transformer source destination)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-compile-edn"><h3>compile-edn</h3><div class="usage"><code>(compile-edn path)</code></div><div class="doc"><div class="markdown"><p>Compile a stylesheet defined in an EDN file.</p>
<p>To write an EDN stylesheet, instead of calling the functions in the <code>sigel.xslt.elements</code> namespace, use the <code>:xsl</code> namespace prefix like this:</p>
<pre><code>;; a.edn
[:xsl/stylesheet {:version 3.0}
  [:xsl/template {:match "a"} [:b]]]
</code></pre>
<p>Then compile the stylesheet and transform some XML with it:</p>
<pre><code>(xslt/transform (xslt/compile-edn "resources/examples/a.edn") "&lt;a/&gt;")
;;=&gt; #object[net.sf.saxon.s9api.XdmNode 0xf2a49c4 "&lt;b/&gt;"]
</code></pre></div></div></div><div class="public anchor" id="var-compile-sexp"><h3>compile-sexp</h3><div class="usage"><code>(compile-sexp compiler stylesheet)</code><code>(compile-sexp stylesheet)</code></div><div class="doc"><div class="markdown"><p>Compile an XSLT stylesheet written in Clojure.</p>
<p>If you don’t pass in an <a href="http://www.saxonica.com/html/documentation/javadoc/net/sf/saxon/s9api/XsltCompiler.html">XsltCompiler</a>, Sigel uses <a href="sigel.xslt.core.html#var-*compiler*">*compiler*</a>.</p>
<p>You can execute the compiled stylesheet with <a href="sigel.xslt.core.html#var-transform">transform</a>.</p>
<p>Example:</p>
<pre><code>;; Define an XSLT stylesheet.
(def stylesheet
  (xsl/stylesheet {:version 3.0}
    (xsl/template {:match "a"} [:b])))

;; Compile the stylesheet.
(xslt/compile-sexp stylesheet)
;;=&gt; #object[net.sf.saxon.s9api.XsltExecutable 0x1098b3aa "net.sf.saxon.s9api.XsltExecutable@1098b3aa"]
</code></pre></div></div></div><div class="public anchor" id="var-compile-source"><h3>compile-source</h3><div class="usage"><code>(compile-source compiler stylesheet)</code><code>(compile-source stylesheet)</code></div><div class="doc"><div class="markdown"><p>Compile an XSLT stylesheet from a <a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/transform/Source.html">Source</a>.</p></div></div></div><div class="public anchor" id="var-compile-xslt"><h3>compile-xslt</h3><div class="usage"><code>(compile-xslt path)</code></div><div class="doc"><div class="markdown"><p>Compile a stylesheet defined in an XML file.</p></div></div></div><div class="public anchor" id="var-compiler"><h3>compiler</h3><div class="usage"><code>(compiler)</code></div><div class="doc"><div class="markdown"><p>Create a new <a href="http://www.saxonica.com/html/documentation/javadoc/net/sf/saxon/s9api/XsltCompiler.html">XsltCompiler</a>.</p></div></div></div><div class="public anchor" id="var-pipeline"><h3>pipeline</h3><div class="usage"><code>(pipeline [ex &amp; exs] params source destination)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-transform"><h3>transform</h3><div class="usage"><code>(transform executables params source)</code><code>(transform executables source)</code></div><div class="doc"><div class="markdown"><p>Execute one or more XSLT transformations on the given source file.</p>
<p>Example:</p>
<pre><code>;; Define an XSLT transformation.
(def stylesheet
  (xslt3-identity (xsl/template {:match "a"} [:b])))

;; Compile the stylesheet and use it to transform "&lt;a/&gt;".
(xslt/transform (xslt/compile-sexp stylesheet) "&lt;a/&gt;")
;;=&gt; "&lt;b/&gt;"
</code></pre>
<p>To execute multiple transformations in sequence, pass a sequence of compiled stylesheets.</p>
<p>Example:</p>
<pre><code>(def stylesheet-1
  (xslt3-identity (xsl/template {:match "a"} [:b])))

(def stylesheet-2
  (xslt3-identity (xsl/template {:match "b"} [:c])))

(def compiled-stylesheets
  [(xslt/compile-sexp stylesheet-1) (xslt/compile-sexp stylesheet-2)])

(xslt/transform compiled-stylesheets "&lt;a/&gt;")
;;=&gt; "&lt;c/&gt;"
</code></pre>
<p>You can pass a map of parameters to the XSLT stylesheet.</p>
<p>Example:</p>
<pre><code>(def xslt
  (xsl/stylesheet {:version 3.0 :xmlns:xs "http://www.w3.org/2001/XMLSchema"}
    (xsl/param {:name "factor" :as "xs:integer"})

    (xsl/template {:match "num"}
      (xsl/copy (xsl/value-of {:select "xs:int(.) * $factor"})))))

(xslt/transform (xslt/compile-sexp xslt) {:factor 10} "&lt;num&gt;1&lt;/num&gt;")
;;=&gt; "&lt;num&gt;10&lt;/num&gt;"
</code></pre></div></div></div><div class="public anchor" id="var-transform-to-file"><h3>transform-to-file</h3><div class="usage"><code>(transform-to-file executables params source target)</code><code>(transform-to-file executables source target)</code></div><div class="doc"><div class="markdown"><p>Execute one or more XSLT transformations on the given source file.</p>
<p>See also <a href="sigel.xslt.core.html#var-transform">transform</a>.</p>
<p>Example:</p>
<pre><code>;; Define an XSLT transformation.
(def stylesheet
  (xslt3-identity (xsl/template {:match "a"} [:b])))

;; Compile the stylesheet and use it to transform "&lt;a/&gt;".
;;
;; Save the result of the transformation into "/tmp/b.xml".
(xslt/transform-to-file (xslt/compile-sexp stylesheet)
                        "&lt;a/&gt;"
                        (io/file "/tmp/b.xml")
</code></pre></div></div></div></div></body></html>